<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shell Helper ç›£æ§å„€è¡¨æ¿</title>
    <link rel="stylesheet" href="/static/dashboard.css">
    <!-- å¼•å…¥ marked.js ç”¨æ–¼ Markdown æ¸²æŸ“ -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ–¥ï¸ Shell Helper ç›£æ§å„€è¡¨æ¿</h1>
            <div class="update-time">
                <span id="last-update">è¼‰å…¥ä¸­...</span>
                <span class="loading-indicator" id="loading-indicator" style="display: none;"></span>
            </div>
        </header>

        <div class="content">
            <!-- æ‘˜è¦çµ±è¨ˆå¡ç‰‡ -->
            <div class="summary-cards" id="summary-cards">
                <div class="card">
                    <div class="card-icon">ğŸ“Š</div>
                    <div class="card-label">ç¸½æ¸¬è©¦æ•¸</div>
                    <div class="card-value" id="total-tests">-</div>
                </div>
                <div class="card success">
                    <div class="card-icon">âœ…</div>
                    <div class="card-label">æˆåŠŸ</div>
                    <div class="card-value" id="success-tests">-</div>
                </div>
                <div class="card failure">
                    <div class="card-icon">âŒ</div>
                    <div class="card-label">å¤±æ•—</div>
                    <div class="card-value" id="failure-tests">-</div>
                </div>
                <div class="card rate">
                    <div class="card-icon">ğŸ“ˆ</div>
                    <div class="card-label">æˆåŠŸç‡</div>
                    <div class="card-value" id="success-rate">-</div>
                </div>
            </div>

            <!-- æ§åˆ¶æŒ‰éˆ•å€åŸŸ -->
            <div class="controls">
                <button class="btn btn-primary" onclick="toggleAllTests()">
                    <span id="toggle-text">ğŸ“– å±•é–‹å…¨éƒ¨</span>
                </button>
                <button class="btn btn-secondary" onclick="filterTests('all')" id="filter-all">
                    å…¨éƒ¨
                </button>
                <button class="btn btn-success" onclick="filterTests('success')" id="filter-success">
                    âœ… æˆåŠŸ
                </button>
                <button class="btn btn-danger" onclick="filterTests('failure')" id="filter-failure">
                    âŒ å¤±æ•—
                </button>

                <!-- åˆ·æ–°é–“éš”è¨­ç½® -->
                <div class="refresh-settings">
                    <label for="refresh-interval">â±ï¸ åˆ·æ–°é–“éš”ï¼š</label>
                    <select id="refresh-interval" class="interval-select" onchange="updateRefreshInterval()">
                        <option value="3000">3 ç§’</option>
                        <option value="5000" selected>5 ç§’</option>
                        <option value="10000">10 ç§’</option>
                        <option value="30000">30 ç§’</option>
                        <option value="60000">1 åˆ†é˜</option>
                        <option value="custom">è‡ªè¨‚...</option>
                    </select>
                    <input type="number" id="custom-interval" class="custom-input" placeholder="ç§’" min="1" max="3600" style="display: none;">
                    <button id="apply-custom" class="btn-small" onclick="applyCustomInterval()" style="display: none;">å¥—ç”¨</button>
                </div>
            </div>

            <!-- éŒ¯èª¤è¨Šæ¯å€åŸŸ -->
            <div id="error-container"></div>

            <!-- æ¸¬è©¦çµæœæ™‚é–“ç·š -->
            <div class="results-section">
                <h2 class="section-title">ğŸ“‹ æ¸¬è©¦çµæœæ™‚é–“ç·š</h2>
                <div id="test-timeline">
                    <div class="loading-message">æ­£åœ¨è¼‰å…¥æ¸¬è©¦çµæœ...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let refreshInterval;
        let allExpanded = false;
        let currentFilter = 'all';
        let testResults = [];
        let REFRESH_INTERVAL = 5000; // é è¨­ 5 ç§’

        // å¾ localStorage è¼‰å…¥è¨­ç½®
        function loadSettings() {
            const savedInterval = localStorage.getItem('refreshInterval');
            if (savedInterval) {
                REFRESH_INTERVAL = parseInt(savedInterval);
                const select = document.getElementById('refresh-interval');

                // æŸ¥æ‰¾åŒ¹é…çš„é¸é …
                let found = false;
                for (let option of select.options) {
                    if (option.value === savedInterval) {
                        select.value = savedInterval;
                        found = true;
                        break;
                    }
                }

                // å¦‚æœæ²’æœ‰åŒ¹é…çš„é¸é …ï¼Œè¨­ç‚ºè‡ªè¨‚
                if (!found && savedInterval !== 'custom') {
                    select.value = 'custom';
                    showCustomInput();
                    document.getElementById('custom-interval').value = Math.floor(REFRESH_INTERVAL / 1000);
                }
            }
        }

        // å„²å­˜è¨­ç½®åˆ° localStorage
        function saveSettings() {
            localStorage.setItem('refreshInterval', REFRESH_INTERVAL.toString());
        }

        // æ›´æ–°åˆ·æ–°é–“éš”
        function updateRefreshInterval() {
            const select = document.getElementById('refresh-interval');
            const value = select.value;

            if (value === 'custom') {
                showCustomInput();
            } else {
                hideCustomInput();
                REFRESH_INTERVAL = parseInt(value);
                saveSettings();
                restartAutoRefresh();
            }
        }

        // é¡¯ç¤ºè‡ªè¨‚è¼¸å…¥æ¡†
        function showCustomInput() {
            document.getElementById('custom-interval').style.display = 'inline-block';
            document.getElementById('apply-custom').style.display = 'inline-block';
        }

        // éš±è—è‡ªè¨‚è¼¸å…¥æ¡†
        function hideCustomInput() {
            document.getElementById('custom-interval').style.display = 'none';
            document.getElementById('apply-custom').style.display = 'none';
        }

        // å¥—ç”¨è‡ªè¨‚é–“éš”
        function applyCustomInterval() {
            const customValue = document.getElementById('custom-interval').value;
            if (customValue && customValue > 0 && customValue <= 3600) {
                REFRESH_INTERVAL = parseInt(customValue) * 1000; // è½‰æ›ç‚ºæ¯«ç§’
                saveSettings();
                restartAutoRefresh();
                alert(`âœ… å·²è¨­å®šåˆ·æ–°é–“éš”ç‚º ${customValue} ç§’`);
            } else {
                alert('âš ï¸ è«‹è¼¸å…¥ 1-3600 ä¹‹é–“çš„ç§’æ•¸');
            }
        }

        // é‡æ–°å•Ÿå‹•è‡ªå‹•åˆ·æ–°
        function restartAutoRefresh() {
            stopAutoRefresh();
            startAutoRefresh();
        }

        // æ ¼å¼åŒ–æ™‚é–“
        function formatTime(date) {
            return date.toLocaleString('zh-TW', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        // é¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
        function showError(message) {
            const errorContainer = document.getElementById('error-container');
            errorContainer.innerHTML = `
                <div class="error-message">
                    âš ï¸ <strong>éŒ¯èª¤ï¼š</strong>${message}
                </div>
            `;
        }

        // æ¸…é™¤éŒ¯èª¤è¨Šæ¯
        function clearError() {
            document.getElementById('error-container').innerHTML = '';
        }

        // æ ¼å¼åŒ–è¼¸å‡ºçµæœï¼ˆä½¿ç”¨ markdown é¢¨æ ¼ï¼‰
        function formatOutput(output) {
            if (!output) return '';

            // è™•ç†è½‰ç¾©çš„æ›è¡Œç¬¦
            output = output.replace(/\\n/g, '\n');

            const lines = output.split('\n');
            let formattedHtml = '';
            let i = 0;

            while (i < lines.length) {
                const line = lines[i];

                // æª¢æ¸¬æ¨™é¡Œå€å¡Šï¼ˆ===== é–‹é ­ï¼‰
                if (line.match(/^=+\s*.+\s*=+$/)) {
                    formattedHtml += `<div class="output-section-title">${escapeHtml(line)}</div>`;
                    i++;
                    continue;
                }

                // æª¢æ¸¬ç©ºç™½åˆ†éš”ç·š
                if (line.match(/^=+$/)) {
                    formattedHtml += '<hr class="output-separator">';
                    i++;
                    continue;
                }

                // æª¢æ¸¬è¡¨æ ¼ï¼ˆæŸ¥æ‰¾ä¸‹ä¸€è¡Œæ˜¯å¦ç‚ºåˆ†éš”ç·šï¼‰
                if (i + 1 < lines.length) {
                    const nextLine = lines[i + 1];
                    // PowerShell è¡¨æ ¼ç‰¹å¾µï¼šç•¶å‰è¡Œæœ‰å…§å®¹ï¼Œä¸‹ä¸€è¡Œå…¨æ˜¯ - å’Œç©ºæ ¼
                    if (line.trim() && nextLine.match(/^[-\s]+$/) && nextLine.includes('-')) {
                        // é€™æ˜¯è¡¨æ ¼é–‹å§‹
                        const tableResult = parseTable(lines, i);
                        formattedHtml += tableResult.html;
                        i = tableResult.nextIndex;
                        continue;
                    }
                }

                // æ™®é€šæ–‡æœ¬è¡Œ
                if (line.trim()) {
                    // æª¢æŸ¥æ˜¯å¦ç‚ºéµå€¼å°æ ¼å¼ï¼ˆå¦‚ "ç¸½è¨˜æ†¶é«”: 15.85 GB"ï¼‰
                    if (line.includes(':') && !line.startsWith(' ')) {
                        formattedHtml += `<div class="output-key-value">${escapeHtml(line)}</div>`;
                    } else {
                        formattedHtml += `<div class="output-line">${escapeHtml(line)}</div>`;
                    }
                } else {
                    formattedHtml += '<div class="output-line">&nbsp;</div>';
                }

                i++;
            }

            return formattedHtml || `<pre class="output-fallback">${escapeHtml(output)}</pre>`;
        }

        // è§£æè¡¨æ ¼
        function parseTable(lines, startIndex) {
            const headerLine = lines[startIndex];
            const separatorLine = lines[startIndex + 1];

            // é€šéåˆ†éš”ç·šç¢ºå®šåˆ—çš„ä½ç½®
            const columnPositions = [];
            let inDash = false;
            let startPos = 0;

            for (let i = 0; i < separatorLine.length; i++) {
                if (separatorLine[i] === '-' && !inDash) {
                    inDash = true;
                    startPos = i;
                } else if (separatorLine[i] !== '-' && inDash) {
                    inDash = false;
                    columnPositions.push({ start: startPos, end: i });
                }
            }

            // å¦‚æœæœ€å¾Œé‚„åœ¨ dash ä¸­
            if (inDash) {
                columnPositions.push({ start: startPos, end: separatorLine.length });
            }

            // å¾è¡¨é ­ä¸­æå–åˆ—å
            const headers = columnPositions.map(pos =>
                headerLine.substring(pos.start, pos.end).trim()
            );

            let tableHtml = '<table class="output-table"><thead><tr>';
            headers.forEach(header => {
                tableHtml += `<th>${escapeHtml(header)}</th>`;
            });
            tableHtml += '</tr></thead><tbody>';

            // è§£ææ•¸æ“šè¡Œ
            let i = startIndex + 2; // è·³éè¡¨é ­å’Œåˆ†éš”ç·š
            while (i < lines.length) {
                const dataLine = lines[i];

                // æª¢æŸ¥æ˜¯å¦ç‚ºç©ºè¡Œæˆ–è¡¨æ ¼çµæŸ
                if (!dataLine.trim()) {
                    break;
                }

                // æª¢æŸ¥æ˜¯å¦é‚„æ˜¯è¡¨æ ¼å…§å®¹ï¼ˆå¦‚æœè¡Œå¤ªçŸ­æˆ–æ ¼å¼ä¸å°ï¼Œè¡¨æ ¼çµæŸï¼‰
                if (dataLine.length < separatorLine.length * 0.5) {
                    break;
                }

                // æå–å–®å…ƒæ ¼æ•¸æ“š - ä½¿ç”¨æ›´éˆæ´»çš„æ–¹æ³•
                const cells = columnPositions.map((pos, idx) => {
                    // å°æ–¼æ¯ä¸€åˆ—ï¼Œå¾åˆ†éš”ç·šèµ·å§‹ä½ç½®å‘å‰æœ€å¤š 10 å€‹å­—ç¬¦é–‹å§‹æœç´¢
                    const searchStart = Math.max(0, pos.start - 10);
                    const nextColStart = idx < columnPositions.length - 1 ?
                        columnPositions[idx + 1].start : dataLine.length;

                    // æå–é€™å€‹ç¯„åœå…§çš„æ–‡æœ¬
                    const rawText = dataLine.substring(searchStart, nextColStart);

                    // åˆ†å‰²æˆå–®è©ï¼ˆæŒ‰ç©ºæ ¼ï¼‰
                    const words = rawText.trim().split(/\s+/).filter(w => w);

                    // å°æ–¼ç¬¬ä¸€åˆ—ï¼Œå¯èƒ½åŒ…å«å¤šå€‹å–®è©ï¼ˆå¦‚ "Memory Compression"ï¼‰
                    if (idx === 0) {
                        // æ‰¾åˆ°æœ€å¾Œä¸€å€‹çœ‹èµ·ä¾†åƒæ•¸å­—çš„å–®è©çš„ä½ç½®
                        let lastWordIdx = words.length;
                        for (let j = words.length - 1; j >= 0; j--) {
                            if (/^\d+$/.test(words[j]) || /^\d+\.\d+$/.test(words[j])) {
                                lastWordIdx = j;
                                break;
                            }
                        }
                        return words.slice(0, lastWordIdx).join(' ');
                    }

                    // å°æ–¼å…¶ä»–åˆ—ï¼Œå–æœ€å¾Œä¸€å€‹å–®è©ï¼ˆæœ€é è¿‘è©²åˆ—ä½ç½®çš„å€¼ï¼‰
                    return words.length > 0 ? words[words.length - 1] : '';
                });

                // å¦‚æœæ‰€æœ‰å–®å…ƒæ ¼éƒ½ç‚ºç©ºï¼Œè¡¨æ ¼çµæŸ
                if (cells.every(cell => !cell)) {
                    break;
                }

                tableHtml += '<tr>';
                cells.forEach(cell => {
                    tableHtml += `<td>${escapeHtml(cell || '-')}</td>`;
                });
                tableHtml += '</tr>';

                i++;
            }

            tableHtml += '</tbody></table>';

            return {
                html: tableHtml,
                nextIndex: i
            };
        }

        // è§£æ Markdown å…§å®¹
        function parseTestResults(markdown) {
            const tests = [];
            const sections = markdown.split(/={10,}/); // åˆ†å‰²ä¸åŒæ™‚é–“çš„æ¸¬è©¦å ±å‘Š

            sections.forEach(section => {
                if (!section.trim()) return;

                // æå–æ¸¬è©¦æ™‚é–“
                const timeMatch = section.match(/æ¸¬è©¦æ™‚é–“:\s*(.+)/);
                const testTime = timeMatch ? timeMatch[1] : '';

                // æå–æ¯å€‹æ¸¬è©¦é …ç›®
                const testMatches = section.matchAll(/### æ¸¬è©¦ (\d+)([\s\S]*?)(?=### æ¸¬è©¦ \d+|$)/g);

                for (const match of testMatches) {
                    const testNumber = match[1];
                    const content = match[2];

                    // æå–æ¸¬è©¦è©³æƒ…ï¼ˆåŒ¹é… Markdown ç²—é«”æ¨™è¨˜ **ï¼‰
                    const execTime = content.match(/\*\*åŸ·è¡Œæ™‚é–“\*\*:\s*(.+)/)?.[1] || '';
                    const command = content.match(/\*\*åŸ·è¡Œå‘½ä»¤\*\*:\s*`(.+)`/)?.[1] || '';
                    const platform = content.match(/\*\*æŒ‡å®šå¹³å°\*\*:\s*(.+)/)?.[1] || '';
                    const status = content.match(/\*\*ç‹€æ…‹\*\*:\s*(.+)/)?.[1] || '';
                    const actualPlatform = content.match(/\*\*å¯¦éš›å¹³å°\*\*:\s*(.+)/)?.[1] || '';
                    const returnCode = content.match(/\*\*è¿”å›ç¢¼\*\*:\s*(\d+)/)?.[1] || '';

                    // æå–è¼¸å‡ºçµæœï¼ˆè™•ç† ``` å¾Œçš„æ›è¡Œï¼‰
                    const outputMatch = content.match(/\*\*è¼¸å‡ºçµæœ\*\*:\s*```\n?([\s\S]*?)```/);
                    const output = outputMatch ? outputMatch[1].trim() : '';

                    // åˆ¤æ–·æ˜¯å¦æˆåŠŸ
                    const isSuccess = status.includes('âœ…') || status.includes('æˆåŠŸ');

                    tests.push({
                        number: testNumber,
                        time: testTime,
                        execTime,
                        command,
                        platform,
                        status: isSuccess ? 'success' : 'failure',
                        actualPlatform,
                        returnCode,
                        output,
                        expanded: false
                    });
                }
            });

            return tests.reverse(); // æœ€æ–°çš„åœ¨å‰é¢
        }

        // æ›´æ–°æ‘˜è¦å¡ç‰‡
        function updateSummaryCards(tests) {
            const total = tests.length;
            const success = tests.filter(t => t.status === 'success').length;
            const failure = total - success;
            const rate = total > 0 ? Math.round((success / total) * 100) : 0;

            document.getElementById('total-tests').textContent = total;
            document.getElementById('success-tests').textContent = success;
            document.getElementById('failure-tests').textContent = failure;
            document.getElementById('success-rate').textContent = rate + '%';
        }

        // æ¸²æŸ“å–®å€‹æ¸¬è©¦é …ç›®
        function renderTestItem(test, index) {
            const statusIcon = test.status === 'success' ? 'âœ…' : 'âŒ';
            const statusText = test.status === 'success' ? 'æˆåŠŸ' : 'å¤±æ•—';
            const statusClass = test.status === 'success' ? 'success' : 'failure';

            // æ ¼å¼åŒ–è¼¸å‡º
            const formattedOutput = formatOutput(test.output);

            return `
                <div class="test-card ${statusClass}" data-status="${test.status}" data-index="${index}">
                    <div class="test-card-header" onclick="toggleTest(${index})">
                        <div class="test-card-title">
                            <span class="test-number">æ¸¬è©¦ ${test.number}</span>
                            <span class="status-badge ${statusClass}">${statusIcon} ${statusText}</span>
                        </div>
                        <div class="test-card-meta">
                            <span class="meta-item">â° ${test.execTime}</span>
                            <span class="meta-item">ğŸ’» ${test.actualPlatform}</span>
                            <span class="meta-item">â†©ï¸ è¿”å›ç¢¼: ${test.returnCode}</span>
                        </div>
                        <div class="expand-icon ${test.expanded ? 'expanded' : ''}">â–¼</div>
                    </div>

                    <div class="test-card-body ${test.expanded ? 'expanded' : ''}">
                        <div class="test-detail-grid">
                            <div class="detail-item">
                                <div class="detail-label">ğŸ”§ åŸ·è¡Œå‘½ä»¤</div>
                                <div class="detail-value command">${escapeHtml(test.command)}</div>
                            </div>
                            <div class="detail-item">
                                <div class="detail-label">ğŸ¯ æŒ‡å®šå¹³å°</div>
                                <div class="detail-value">${test.platform}</div>
                            </div>
                        </div>

                        ${test.output ? `
                            <div class="output-section">
                                <div class="output-header">ğŸ“¤ è¼¸å‡ºçµæœ</div>
                                <div class="output-content formatted">${formattedOutput}</div>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        // HTML è½‰ç¾©
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // æ¸²æŸ“æ‰€æœ‰æ¸¬è©¦é …ç›®
        function renderAllTests() {
            const timeline = document.getElementById('test-timeline');

            if (testResults.length === 0) {
                timeline.innerHTML = '<div class="empty-message">ğŸ“­ å°šç„¡æ¸¬è©¦çµæœ</div>';
                return;
            }

            const html = testResults.map((test, index) => renderTestItem(test, index)).join('');
            timeline.innerHTML = html;

            // æ‡‰ç”¨ç•¶å‰éæ¿¾å™¨
            applyFilter();
        }

        // åˆ‡æ›å–®å€‹æ¸¬è©¦é …ç›®çš„å±•é–‹/æ”¶èµ·
        function toggleTest(index) {
            testResults[index].expanded = !testResults[index].expanded;
            renderAllTests();
        }

        // åˆ‡æ›æ‰€æœ‰æ¸¬è©¦é …ç›®çš„å±•é–‹/æ”¶èµ·
        function toggleAllTests() {
            allExpanded = !allExpanded;
            testResults.forEach(test => test.expanded = allExpanded);
            document.getElementById('toggle-text').textContent = allExpanded ? 'ğŸ“• æ”¶èµ·å…¨éƒ¨' : 'ğŸ“– å±•é–‹å…¨éƒ¨';
            renderAllTests();
        }

        // éæ¿¾æ¸¬è©¦çµæœ
        function filterTests(filter) {
            currentFilter = filter;

            // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            document.querySelectorAll('.controls .btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`filter-${filter}`).classList.add('active');

            applyFilter();
        }

        // æ‡‰ç”¨éæ¿¾å™¨
        function applyFilter() {
            const cards = document.querySelectorAll('.test-card');
            cards.forEach(card => {
                const status = card.getAttribute('data-status');
                if (currentFilter === 'all' || currentFilter === status) {
                    card.style.display = 'block';
                } else {
                    card.style.display = 'none';
                }
            });
        }

        // ç²å–ä¸¦é¡¯ç¤ºæ¸¬è©¦çµæœ
        async function fetchTestResults() {
            const loadingIndicator = document.getElementById('loading-indicator');

            try {
                loadingIndicator.style.display = 'inline-block';

                // ç²å–åŸå§‹ Markdown å…§å®¹
                const response = await fetch('/api/test-results/raw');

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                // API è¿”å›çš„æ˜¯ JSON å­—ç¬¦ä¸²ï¼Œéœ€è¦å…ˆè§£æ
                const text = await response.text();
                const markdown = JSON.parse(text);

                // è§£ææ¸¬è©¦çµæœ
                testResults = parseTestResults(markdown);

                // æ›´æ–°æ‘˜è¦
                updateSummaryCards(testResults);

                // æ¸²æŸ“æ¸¬è©¦é …ç›®
                renderAllTests();

                // æ›´æ–°æœ€å¾Œæ›´æ–°æ™‚é–“
                document.getElementById('last-update').textContent =
                    `æœ€å¾Œæ›´æ–°ï¼š${formatTime(new Date())}`;

                clearError();

            } catch (error) {
                console.error('ç²å–æ¸¬è©¦çµæœå¤±æ•—:', error);
                showError(`ç„¡æ³•è¼‰å…¥æ¸¬è©¦çµæœï¼š${error.message}`);
                document.getElementById('test-timeline').innerHTML =
                    '<div class="error-message">âš ï¸ ç„¡æ³•è¼‰å…¥æ¸¬è©¦çµæœ</div>';
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        // å•Ÿå‹•è‡ªå‹•åˆ·æ–°
        function startAutoRefresh() {
            // ç«‹å³åŸ·è¡Œä¸€æ¬¡
            fetchTestResults();

            // è¨­å®šå®šæ™‚åˆ·æ–°
            refreshInterval = setInterval(fetchTestResults, REFRESH_INTERVAL);
        }

        // åœæ­¢è‡ªå‹•åˆ·æ–°
        function stopAutoRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
            }
        }

        // é é¢è¼‰å…¥å®Œæˆå¾Œå•Ÿå‹•è‡ªå‹•åˆ·æ–°
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings(); // è¼‰å…¥è¨­ç½®
            startAutoRefresh();
            // é è¨­é¸ä¸­ "å…¨éƒ¨" éæ¿¾å™¨
            document.getElementById('filter-all').classList.add('active');
        });

        // é é¢å¸è¼‰æ™‚åœæ­¢åˆ·æ–°
        window.addEventListener('beforeunload', () => {
            stopAutoRefresh();
        });

        // é é¢å¯è¦‹æ€§è®ŠåŒ–æ™‚æ§åˆ¶åˆ·æ–°
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                stopAutoRefresh();
            } else {
                startAutoRefresh();
            }
        });
    </script>
</body>
</html>
